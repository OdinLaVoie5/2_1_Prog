# rhyme.py  для  analyze_poem        ПРОВЕРКА РИФМ    
import re
from clean import clean_cyr_word


# стихи отмеченные * (на месте первой буквы) ПРОПУСКАЕМ БЕЗ ПРОВЕРКИ РИФМЫ


VOWELS     = "аэоуяеёюиыАЭОУЯЕЁЮИЫ" 
CONSONANTS = "бвгджзйклмнпрстфхцчшщьъБВГДЖЗЙКЛМНПРСТФХЦЧШЩЬЪ"   # добавил ь, ъ для remove_doubles_cons (после карты могут дублироваться)

#################### ПАРАМЕТРЫ ПРОГРАММЫ ###########################
####################################################################  
MODE=None  # ??? нужно менять     см  rhyme_var_li.py в доп     УДАЛИЛ это. сделал жёсткую замену ударного по карте 2. остального по карте 1. 
# может сделать моды  но по другим принципам?       -- был выбор по карте    1 - упрощённый, 2 - полный 
  # предударный слог и послеударный хвост  после мода 2  упрощаются модом 1 (изменить? управлять?  ???)

EASY=0  # ВЫБОР РЕЖИМА ПРОВЕРКИ РИФМ (глубины)  0 - лёгкий (ударный слог), 1 - средний (с гласной в предударном слоге),   иначе (н/р 2) - тяжелый (с предударным слогом)
#################################################################### 



"""           ВАРИАНТ I (упрощённый)
Определить другие замены, выпадания ...     ??     

Определить другие родственные буквы     ??   
"""

REPLACES_1   = {      # карта 1  для безударных  (дополнительная к 2  не самостоятельная добивка, упрощение) 
"ь": "", "й": "",         # не различать мягкие-твёрдые 

"ц": "с", "щ": "ш", "ч": "ш",       
"с": "ш",    # от логопедов  и  иностранцев  р-г р-а ?    л-в (ло лу лы ?)               
"м": "н", "р": "л",     # м-л ?    п-ф(б-в) т-с ф-с

"и": "е", "о": "а",    # должно быть до   к базовым гласным    чтобы не стало ё-а ы-е
# к базовым гласным
"я": "а", "э": "е", "ё": "о", "ю": "у", "ы": "и",   # ? перенести в 2? некоторые?   беру базовой е, может правильней э?  "е": "э",  ?
}


"""  ??       ВАРИАНТ II (усложнённый)
    Различаются (ударные) производные гласные ("ая" "эе" "оё" "ую"   "ыи") 
    ь, й  перед согласными и в конце строки сохраняются 
    Значит - различаются твёрдые и мягкие звуки  ? 
"""
REPLACES_2 = { 
########################## замены до ОБЪЕДИНЕНИЯ 
############# до оглушения согласных
"жё": "жо",            
"вств": "ств",     "его ": "ево ", "ого ": "ово ",
############## в начале слов 
" чт": " шт",

############# к глухим согласным
"б": "п", "в": "ф", "д": "т",     # зс(ц) гкх? жшщ(ч)   (МН)?  (лр  й)   ^^
"з": "с", "г": "к",  "ж": "ш",     "х": "к",  # ?  х-к убрать в карту 1?  
         
############# после оглушения согласных
"шь": "ш", "ць": "ц",  "ши": "шы",  "ци": "цы", "це": "цэ",     # жш, ц ?  всегда твёрдые  
"щ": "щь", "ч": "чь",                  #   щ,  ч  всегда мягкие
"ться": "ца", "тся": "ца",  "сч": "щ",
"лнц": "нц", "стн": "сн",        
############# на стыке слов
"с и": "сы",    #  ??  неуверен      всё проверить 


" ": "",  ########################## удаляем пробелы  ОБЪЕДИНЕНИЕ
"ъ": "",               # удаляем твёрдый ъ  


# ь + гласные
"ья": "я", "ье": "е", "ьё": "ё", "ью": "ю", "ьи": "и", "ьы": "ы",
"ьа": "я", "ьэ": "е", "ьо": "ё", "ьу": "ю",   

# й + гласные
"йя": "я", "йе": "е", "йё": "ё", "йю": "ю", "йи": "и", "йы": "ы",
"йа": "я", "йэ": "е", "йо": "ё", "йу": "ю",


"тс": "ц", "тьс": "ц", "тц": "ц", "тьц": "ц", "цс": "ц",        # т.к. ц=тс      
"тч": "ч",         
} 



# мой фономизатор по моему словарю REPLACES     
def fix_with_dict(line: str, replaces=None) -> str:
    if replaces is None: replaces = REPLACES_2
    for old, new in replaces.items():
        line = line.replace(old, new)
    return line

# убираем двойные согласные
def remove_doubles_cons(text: str) -> str:
    return re.sub(rf"([{CONSONANTS}])\1+", r"\1", text, flags=re.IGNORECASE)



# разбиваем слово на блоки (условные слоги)  возвращает список (phon_list)
def split_for_rhyme(word: str) -> list[str]:
    vowels = "аеёиоуыэюя"
    result = []
    current = []
    i = len(word) - 1

    while i >= 0:
        ch = word[i]
        current.append(ch)

        if ch in vowels:
            if i - 1 >= 0 and word[i - 1] not in vowels:
                current.append(word[i - 1])
                i -= 1
            # добавляем блок как строку (перевёрнутый, т.к. шли с конца)
            result.append("".join(reversed(current)))
            current = []
        i -= 1

    if current:
        result.append("".join(reversed(current)))

    result.reverse()
    return result



# возвращает словарь с ещё не проверенными рифмами
def extract_rhyme_tail(phon_list: list[list], scheme: tuple, rhymes: str):
    rhymes_dict = {}
    min_len = min(len(phon_list), len(scheme), len(rhymes))

    # ?? сделать числовой вариант rhymes (н/р 1010 какой слог с конца строки)

    for i in range(min_len):
        ch = rhymes[i]
        if ch=="_": continue           # _ - не участвует в рифме

        idx = scheme[i].rfind("+")
        if idx == -1:
            tail = phon_list[i][-1:]   #tail = []   ??   # нет ударения — рифмы нет # может лучше взять последний слог (по умолчанию) 
        else:
            p = len(scheme[i]) - idx        # позиция ударного (1 — последний слог)
            word_phon = phon_list[i]
            n = len(word_phon)

            # безопасные индексы
            add  = word_phon[-p-1] if n > p     else ""
            acc  = word_phon[-p]   if n >= p    else ""
            past = word_phon[-p+1:] if p > 1    else [""]
            tail = [add, acc, *past]    
            # print(tail)

        rhymes_dict.setdefault(ch, []).append(tail)

    return rhymes_dict


#               ФУНКЦИЯ СВЕРКИ 2-х рифм      
#  ??  возможен вариант сравнения не     все с первой строкой     а цепочкой    (есть ли отличия?)
def two_rhymes_fn(a_tail, b_tail, easy) -> bool:
    
    ln = min(len(a_tail), len(b_tail))  # странный случай (теоритически может быть) - если в схеме хвост B длиннее хвоста A  лишок обрезаем  или браковать ??

    for i in range(ln):
        a, b = a_tail[i], b_tail[i]
        if i == 0: 
            if (not a or not b): continue   # нет предударного слога  пропускаем чо уж
            if easy==0: continue       # лёгкий режим пропускаем предударный слог  
            elif easy==1: 
                a = next((ch for ch in a if ch in VOWELS), "") # в предударном слоге берём только гласную 
                b = next((ch for ch in b if ch in VOWELS), "")
            # иначе остаётся полный предударный слог

        if i == 0 or i >= 2:   # ??? разделить i == 0, i = 2 и управлять отдельно?    для первого слога  и  послеударного хвоста  упрощённая карта  
            # ??  стоит ли для хвоста переключать на упрощённую карту?  а может сделать и для ударного? тогда вернуть из карты 1 сюда replace е-и о-а ?
            a = remove_doubles_cons(fix_with_dict(a, REPLACES_1))  # повторно remove_doubles_cons (надо)   
            b = remove_doubles_cons(fix_with_dict(b, REPLACES_1))   
        if a != b:
            return False

    return True

#              ГЛАВНАЯ ФУНКЦИЯ  проверка рифм
def check_rhymes(lines, scheme=None, rhymes=None, easy=None):
    log_norhyme = []
    log_rhyme = []

    if not lines: 
        log_norhyme.append("NO TEXT")
        return log_norhyme, log_rhyme
    
    if isinstance(lines, str):
        lines = lines.splitlines() # если текст, то делаем список строк

    if lines[0] and lines[0][0]=="*":     # отмеченные * пропускаем без проверки РИФМЫ
        return log_norhyme, log_rhyme 
        
    if rhymes is None: rhymes = "abab"  # рифмовка по умолчанию
    if scheme is None: scheme = "+" * len(rhymes)  # схема по умолчанию последние слоги
    if easy is None: easy = EASY  # режим по умолчанию (установлено в глобале)

    phon_list = [split_for_rhyme(remove_doubles_cons(fix_with_dict(clean_cyr_word(line.lower(), allowed_chars="", add=" ")))) for line in lines]
    # print(phon_list)     # отладка
    rhymes_dict = extract_rhyme_tail(phon_list, scheme, rhymes)
    print(rhymes_dict)     # отладка

    """
    Проверяет rhymes_dict.
    - пропускает группы с < 2 элементов
    - если base (первый tail) пустой -> логируем (бракуем) эту группу
    - для каждой оставшейся пары сравниваем tail с base, при несовпадении логируем
    Возвращает список сообщений log_norhyme.
    """

    for group, tails in rhymes_dict.items():
        # пропускаем одиночные группы    ???  доделать   если в схеме не указана одиночка - то надо браеовать  
        if len(tails) < 2:
            log_rhyme.append(f"Группа '{group}': одиночная группа")
            continue

        base = tails[0]

        # если опорный хвост пустой — считаем группу дефектной и логируем
        if not base:
            log_norhyme.append(f"Группа '{group}': опорный хвост пуст (base пуст) — бракуем группу")
            continue

        # сравниваем остальные хвосты с опорным
        for idx, tail in enumerate(tails[1:], start=2):
            if not tail:
                log_norhyme.append(f"Группа '{group}': элемент #{idx} — нет ударения/хвоста")
            elif not two_rhymes_fn(base, tail, easy):
                log_norhyme.append(
                    f"Группа '{group}': элемент #{idx} — не рифмуется "
                    f"(base={''.join(base)!r}, tail={''.join(tail)!r})"
                )
            else:
                log_rhyme.append(
                    f"Группа '{group}': элемент #{idx} — рифмуется "
                    f"(base={''.join(base)!r}, tail={''.join(tail)!r})"                
                )

    return log_norhyme, log_rhyme





# ?  если в posttap есть "ь", то он должен быть в обоих posttap  в одной и той же группе согласных ?? 
#      
#  ль - й  (боль - бой) ?     



"""            ДОПОЛНИТЕЛЬНО
если группа одинаковых букв (3?)        - брак по звуку
если группа из согласных (4?)           - брак по звуку      но: "пространство"  

?  сделать более простой mode 0 - не сравнивать группы согласных (ассонанс)   или группы гласных (конссонанс)     или хотя бы конечные согласные  (пойдёn для больших  index)
"""





if __name__ == "__main__": 
    poem = """олегу снился день рожденья 
как мир огромный круглый огонь 
и странный гость чьё имя десять 
конь"""

    l1, l2 = check_rhymes(poem)       # , ("+-","+-","+-","+-"), rhymes="abab"
    print(l1)
    print(l2)
    #  

